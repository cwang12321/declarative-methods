/* ******************************************************************

	This translator code is provided for the benefit of the
members of the scheduling community who wish to solve the Resource
Constrained Project Scheduling benchmark problems created by Barry Fox
and me.  These files are provided as is.  All efforts will be made to
correct errors in the code, but no development or additions can be
made to support individual users.  Any questions or comments can be
addressed to Mark Ringer (mringer@src.honeywell.com).

	The translator code "schedule" holds a list of "activities"
that have specific attributes.  Each activity has a name, start time,
duration, list of predecssors, and list of resources.  These data
members have accessor functions to both store and retrieve
information.  As an example, code is also included that outputs a file
in a format readable by one of my schedulers.

	There are fourteen files used for the translation.  Most of
these are just lifted from schedulers I have written over the years.
The files have been compiled using the Borland C++ compiler on a PC.
I see no reason they can't be compiled elsewhere.  They do use
templates, so your compiler must at least support them.  The files can
be downloaded and broken up into the consituent pieces in order to be
compiled.

activity.h
duration.h
list.h
miscio.h
mystring.h
mytime.h
plist.h
schedule.h
sglobal.h

bench.cpp  (main)
duration.cpp
miscio.cpp
mystring.cpp
mytime.cpp


Best of Luck,

	Mark Ringer
	mringer@src.honeywell.com

****************************************************************** */

/*
	list.h

	A template to hold list of "anything".  But, usually not pointers.

*/

#ifndef LIST

#include "sglobal.h"

template <class I> class Item
	{
	public:
		Item()
			{
			val = 0;
			next = 0;
			};

		Item(I v)
			{
			val = v;
			next = 0;
			};

		Item *next;
		I val;
	};


template <class L> class List
	{
	public:

		List(L value);
		List(void);
		~List(void);

		void Add(const L& value);	// in order
		void Insert(const L& value);	// at front
		void Append(const L& value);	// at end

		int Destroy(void);		// get rid of the entire list
		Boolean Remove(const L& value);  // get rid of all val
		int Length(void) const;		// number in list
		Boolean Find(const L& value);

		void Reset(void);
		L Traverse(void);
		Boolean Traverse(L& value);

		friend ostream& operator<<(ostream& os, List<L>& list)
			{
			L name;

			os << "(";
			while ( list.Traverse(name) ) os << " " << name;
			os << " )";

			return os;
			};

		const String& Name(void)
			{
			return name;
			};

		void Name(const String& newname)
			{
			name = newname;
			};

	protected:
		Item <L> *list;
		Item <L> *pointer;
		Boolean start_flag;

		Item <L> *End(void);
		String name;

	};



template <class L> List<L>::List(L value)
	{
	list = new Item <L> (value);
	pointer = list;
    start_flag = False;
	}

template <class L> List<L>::List(void)
	{
	list = 0;
	pointer = list;
	start_flag = False;
	}

template <class L> List<L>::~List(void)
	{
	Destroy();
	delete list;
    list = 0;
	}


template <class L> void List<L>::Reset(void)
	{
	start_flag = False;
	}


// Add to the list in order as defined by precedence operators

template <class L> void List<L>::Add(const L& value)
	{
	Item <L> *pt = list, *last = list;

	if ( list == 0 )
		{
		Item <L> *newpt = new Item <L> (value);
		list = newpt;
		pointer = list;
        return;
        }

	if ( value <= list->val )
		{
		Item <L> *newpt = new Item <L> (value);
		newpt->next = list;
		list = newpt;
		return;
		}

	while ( pt )
		{
		if ( value < pt->val )
			{
			Item <L> *newpt = new Item <L> (value);
			newpt->next = last->next;
			last->next = newpt;
			return;
			}
        last = pt;
        pt = pt->next;
        }

	Item <L> *newpt = new Item <L> (value);
	(End())->next = newpt;
	newpt->next = 0;
	return;
	}



// Add to the end of the list

template <class L> void List<L>::Append(const L& value)
	{
	Item <L> *pt=new Item <L> (value);
	if ( list == 0 )
		list = pt;
	else
		(End())->next = pt;
	return;
	}



// Return a pointer to the last object

template <class L> Item <L>* List<L>::End(void)
	{
	Item <L> *prv, *pt;
	for ( prv=pt=list ; pt ; prv=pt, pt=pt->next );
	return prv;
	}



// Deletes all objects with the value "value"

template <class L> Boolean List<L>::Remove(const L& value)
	{
    Boolean flag = False;
	if ( list == 0 ) return flag;
	Item <L> *pt = list, *last = list;

	while ( pt && pt->val == value )
		{
		Item <L> *temp = pt;
		list = pt->next;
		delete temp;
		pt = pt->next;
        flag = True;
        }

	pt = list;
    last = pt;
	pt = pt->next;

	while (pt)
		{
		if ( pt->val == value )
			{
			Item <L> *temp = pt;
			last->next = pt->next;
			delete temp;
			flag = True;
			}
		else  // Todd said do this...
			last = pt;

		pt = pt->next;
        }
	
	return flag;
	}

// Find

template <class L> Boolean List<L>::Find(const L& value)
	{
	if ( list == 0 ) return False;
	Item <L> *pt = list;

// Todd said comment this out....
/*
	while ( pt && pt->val == value )
		return True;

	pt = list;
	pt = pt->next;
*/
	while (pt)
		{
		if ( pt->val == value )
			return True;

		pt = pt->next;
        }
	
	return False;
	}


// Add an item to the beginning of the list

template <class L> void List<L>::Insert(const L& value)
	{
	Item <L> *pt = new Item <L> (value);
	if ( list == 0 )
		list = pt;
	else
       	{
		pt->next = list;
		list = pt;
        }
	return;
	}



// Return the number of objects in the list

template <class L> int List<L>::Length(void) const
	{
	int cnt=0;
	Item <L> *pt = list;
	for ( ; pt ; pt = pt->next, ++cnt);
	return cnt;
	}



// Remove the entire list

template <class L> int List<L>::Destroy(void)
	{
	Item <L> *tmp, *pt=list;
	int cnt=0;

	while (pt)
		{
		tmp = pt;
		pt=pt->next;
		++cnt;
		delete tmp;
		}

	list = 0;
	return cnt;
	}


// Traverse the entire list and return each object

template <class L> L List<L>::Traverse(void)
	{
	if ( list == 0 ) return 0;

	if ( start_flag == False )
		{
		pointer = list;
		start_flag = True;
		return list->val;
		}

	pointer = pointer->next;

	if ( pointer == 0 )
		{
		start_flag = False;
		return 0;
		}

	return pointer->val;
	}

template <class L> Boolean List<L>::Traverse(L& value)
	{
	if ( list == 0 ) return False;

	if ( start_flag == False )
		{
		pointer = list;
		start_flag = True;
        value = list->val;
		return True;
		}

	pointer = pointer->next;

	if ( pointer == 0 )
		{
		start_flag = False;
		return False;
		}

    value = pointer->val;
	return True;
	}



#endif
#define LIST/*
	Duration.h

	Routines for keeping track of durations.  I define a duration as a relative
time.  This is a time that
	has no anchor.  For example, 3 hours is a duration.  10 o'clock on the 15th
of december 1993 is 
	an (absolute) time.

*/

#ifndef DURATION

#include <iostream.h>

#ifndef STRING
#include "mystring.h"
#endif

#ifndef GLOBAL
#include "sglobal.h"
#endif

class Duration
	{
	private:
		long int ticks;

	public:
		Duration(void);
		Duration(const Duration&);
		Duration(long int);
		Duration(const String&);
		~Duration(void);

		String Get(void) const;
		Boolean Set(const String&);

		friend ostream& operator<<(ostream&, const Duration&);
		friend istream& operator>>(istream&, Duration&);

		inline long int Ticks(void) const;

		inline Duration& operator=(  long int );
		inline Duration& operator=(  const Duration& );
		inline Duration& operator+=( const Duration& );
		inline Duration& operator-=( const Duration& );

		inline Duration operator+( const Duration& ) const;
		inline Duration operator-( const Duration& ) const;

		inline Boolean operator!=( const Duration& ) const;
		inline Boolean operator==( const Duration& ) const;
		inline Boolean operator>(  const Duration& ) const;
		inline Boolean operator>=( const Duration& ) const;
		inline Boolean operator<(  const Duration& ) const;
		inline Boolean operator<=( const Duration& ) const;
		
		Boolean Inside(const Duration&, const Duration&) const;

	};

#endif

#define DURATION
/*
	miscio.h

	Miscellaneous IO routines, actually, just a read token routine.
*/

#include "mystring.h"
#include <fstream.h>


#ifndef MISCIO

class Misc_IO
	{


	public:

		Boolean Get(ifstream& input, String& s);

    };

#endif
#define MISCIO
/*
	mystring.h

	Header for a simple implementation of strings.

*/


#ifndef MYSTRING

#include <iostream.h>
#include <stdlib.h>

#ifndef SGLOBAL
#include "sglobal.h"
#endif


class String
	{
	public:

		String();
		String(char*);
		String(int);
		String(long int);
		String(float);
		String(const String&);
		~String();

		void Set(const String&);

		friend ostream& operator<<(ostream&, const String&);
		friend istream& operator>>(istream&, String&);

		char* Get(void) const;
		void To_Lower(void);

		void operator=(char*);
		String& operator+=(const String&);          // ?????????????? does this work?
		friend String operator+(const String&, const String&);
		String& operator=(const String&);
		String& operator=(int);
		String& operator=(long int);


		Boolean Compare(const String&, int) const;
		int Length(void) const;
		char& operator[](int);
		char operator[](int) const;

		void Convert(int& i);
		void Convert(long int& li);
		void Convert(double& d);
		void Convert(long double& ld);

		float Atof(void) const;
		int Atoi(void) const;
		long int Atol(void) const;
		long double Atold(void) const;

		Res_Val_Type Constant_Type(void);

		Boolean operator==(const String&) const;
		Boolean operator==(long int) const;
		Boolean operator==(const char*) const;
		Boolean operator!=(const String&) const;
		Boolean operator>( const String&) const;
		Boolean operator<( const String&) const;
		Boolean operator>=(const String&) const;
		Boolean operator<=(const String&) const;

// for the Time and Duration Classes
		Boolean Check_Time(void) const;


		String Car(void) const;
		String Cdr(void) const;
		int Tokens(void) const;

		String First(void) const;
		String Second(void) const;
		String Third(void) const;
		String Fourth(void) const;
		String Fifth(void) const;
		String Sixth(void) const;
		String Seventh(void) const;

		String Make_Underscores_Spaces(void) const;

	protected:

		char* string;

	};


#endif
#define MYSTRING/*
	Mytime.h

	Class definition for Time

	Implemented with long ints in at one second resolution
	First Time (m_inf) of 00:00:00 01Jan90
	Last Time (p_inf) of 03:14:07 05Feb58 (2058 that is)
*/

#ifndef MYTIME

#include <iostream.h>

#ifndef MYSTRING
#include "mystring.h"
#endif

#ifndef GLOBAL
#include "sglobal.h"
#endif

#ifndef DURATION
#include "duration.h"
#endif

class Time
	{
	private:
		long int ticks;
		Boolean Set_Time(const String&);
		Boolean Set_Date(const String&);

	public:
		Time(void);
		Time(const Time&);
		Time(int);
		Time(long int);  // not pretty, but necessary for copy constructor type stuff
		Time(const String&);
		~Time(void);

		Boolean Set(const String&);
		Boolean Set(const String&, const String&);
		String Get(void) const;

		String Day_Of_Week(void) const;
		Boolean Daylight_Savings(void) const;

		friend ostream& operator<<(ostream&, const Time&);
		friend istream& operator>>(istream&, Time&);

//		long int Ticks(void) const;
inline long int Ticks(void) const
	{
	return ticks;
	};

		inline Time& operator=( const Time& );
		inline Time& operator=( const String& );
		inline Time& operator=( long int );

		inline Time& operator+=( const Duration& );
		inline Time& operator-=( const Duration& );

		inline Time operator+(  const Duration& ) const;
		inline Time operator-(  const Duration& ) const;
		inline Duration operator-( const Time& ) const;

		inline Boolean operator!=( const Time& ) const;
		inline Boolean operator==( const Time& ) const;
//		inline Boolean operator>(  const Time& ) const;
		inline Boolean operator>=( const Time& ) const;
		inline Boolean operator<(  const Time& ) const;
		inline Boolean operator<=( const Time& ) const;


inline Boolean operator>( const Time& t0 ) const
	{
	if ( ticks > t0.Ticks() ) return True;
	else return False;
	};

		Boolean Inside( const Time&, const Time& ) const;

	};

#endif

#define MYTIME
/*
	plist.h

	Template routines to hold lists of pointers.
*/


#ifndef PLIST

#include "sglobal.h"
#include "mystring.h"

template <class I> class PItem
	{
	public:
		PItem(I v=0)
			{
			val = v;
			next = 0;
			};

		PItem *next;
		I val;
	};


template <class L> class PList
	{
	public:

		PList (L value);
		PList (void);
		~PList(void);

		L Add(const L& value);	// in order
		L Add_In(const L& value);	// ??
		L Insert(const L& value);	// at front
		L Append(const L& value);	// at end

		int Destroy(void);		// get rid of all
		Boolean Remove(const L& value);  // get rid of all val
		int Length(void) const;		// number in list
		L Find(const String& value);
		Boolean Find(const L&);
		L Traverse(void);
		void Reset(void);

		PList<L>* And(PList<L>*);

		friend ostream& operator<<(ostream& os, PList<L>& list)
			{
			L name;

				os << "\n(";

				list.Reset();
			while ( name = list.Traverse() )  // was traverse(name)
				{
				os << " " << name;
				}

			os << " )";

			return os;
			};


	protected:
		PItem <L> *list;
		PItem <L> *pointer;
		Boolean start_flag;

		PItem <L> *End(void);

	};

template <class L> PList<L>::PList (L value)
	{
	list = new PItem <L> (value);
	pointer = list;
    start_flag = False;
	}

template <class L> PList<L>::PList (void)
	{
	list = 0;
	pointer = list;
	start_flag = False;
	}

template <class L> PList<L>::~PList(void)
	{
	Destroy();
	list = 0;
	}

template <class L> void PList<L>::Reset(void)
	{
	start_flag = False;
	}



// Take the intersection of two lists

template <class L> PList<L>* PList<L>::And(PList<L>* list)
	{
	L item1,item2;
	PList<L>* retlist = new PList<L>();

	while ( item1 = Traverse() )
		while ( item2 = list->Traverse() )
			if ( item1 == item2 )
				retlist->Add(item1);

	return retlist;
	}



// Add to the list in order as defined by precedence operators

template <class L> L PList<L>::Add(const L& value)
	{
	PItem <L> *pt = list, *last = list;

	if ( list == 0 )
		{
		PItem <L> *newpt = new PItem <L> (value);
		list = newpt;
		pointer = list;
		return newpt->val;
        }

	if ( value->Name() >= list->val->Name() )
		{
		PItem <L> *newpt = new PItem <L> (value);
		newpt->next = list;
		list = newpt;
		return newpt->val;
		}

	while ( pt )
		{
		if ( value->Name() > pt->val->Name() )
			{
			PItem <L> *newpt = new PItem <L> (value);
			newpt->next = last->next;
			last->next = newpt;
			return newpt->val;
			}
        last = pt;
        pt = pt->next;
        }

	PItem <L> *newpt = new PItem <L> (value);
	(End())->next = newpt;
	newpt->next = 0;
	return newpt->val;
	}


template <class L> L PList<L>::Add_In(const L& value)
	{
	PItem <L> *pt = list, *last = list;

	if ( list == 0 )
		{
		PItem <L> *newpt = new PItem <L> (value);
		list = newpt;
		pointer = list;
		return newpt->val;
        }

	if ( value->Name() <= list->val->Name() )
		{
		PItem <L> *newpt = new PItem <L> (value);
		newpt->next = list;
		list = newpt;
		return newpt->val;
		}

	while ( pt )
		{
		if ( value->Name() < pt->val->Name() )
			{
			PItem <L> *newpt = new PItem <L> (value);
			newpt->next = last->next;
			last->next = newpt;
			return newpt->val;
			}
        last = pt;
        pt = pt->next;
        }

	PItem <L> *newpt = new PItem <L> (value);
	(End())->next = newpt;
	newpt->next = 0;
	return newpt->val;
	}




// Add to the end of the list

template <class L> L PList<L>::Append(const L& value)
	{
	PItem <L> *pt=new PItem <L> (value);
	if ( list == 0 )
		list = pt;
	else
		(End())->next = pt;
	return pt->val;
	}



// Return a pointer to the last object

template <class L> PItem <L>* PList<L>::End(void)
	{
	PItem <L> *prv, *pt;
	for ( prv=pt=list ; pt ; prv=pt, pt=pt->next );
	return prv;
	}



// Delete all objects with the value "value"

template <class L> Boolean PList<L>::Remove(const L& value)
	{
	 Boolean flag = False;
	if ( list == 0 ) return flag;
	PItem <L> *pt = list, *last = list;

	while ( pt && pt->val == value )
		{
		PItem <L> *temp = pt;
		list = pt->next;
//        delete temp->val; // just added
		delete temp;
		pt = pt->next;
        flag = True;
        }

	pt = list;
    last = pt;
	if ( pt ) pt = pt->next;
		else return False;

	while (pt)
		{
		if ( pt->val == value )
			{
			PItem <L> *temp = pt;
			last->next = pt->next;
//			delete temp->val; // just added
			delete temp;
			flag = True;
			}
		else // Todd said to do this
			last = pt;

		pt = pt->next;
		  }

	return flag;
	}

// Find

template <class L> L PList<L>::Find(const String& value)
	{
	if ( list == 0 ) return 0;
	PItem <L> *pt = list;

// Todd said to do this
/*
	while ( pt && value == pt->val->Name() )
		return pt->val;

	pt = list;
	pt = pt->next;
*/

	while (pt)
		{
		if ( value == pt->val->Name() ) return pt->val;
		pt = pt->next;
		  }

	return 0;
	}

template <class L> Boolean PList<L>::Find(const L& value )
	{
	if ( list == 0 ) return False;
	PItem <L> *pt = list;

	if ( pt && value == pt->val )
		return True;

	pt = list;
	pt = pt->next;

	while (pt)
		{
		if ( value == pt->val ) return True;
		pt = pt->next;
		}

	return False;
	}


// Add an item to the beginning of the list

template <class L> L PList<L>::Insert(const L& value)
	{
	PItem <L> *pt = new PItem <L> (value);
	if ( list == 0 )
		list = pt;
	else
       	{
		pt->next = list;
		list = pt;
        }
	return pt->val;
	}



// Return the number of objects in the list

template <class L> int PList<L>::Length(void) const
	{
	int cnt=0;
	PItem <L> *pt = list;
	for ( ; pt ; pt = pt->next, ++cnt);
	return cnt;
	}



// Remove the entire list

template <class L> int PList<L>::Destroy(void)
	{
	PItem <L> *tmp, *pt=list;
	int cnt=0;

	while (pt)
		{
		tmp = pt;
		pt=pt->next;
		++cnt;
//		delete tmp->val; // just added
		delete tmp;
		}

	list = 0;
	return cnt;
	}



// Traverse the entire list and return each object

template <class L> L PList<L>::Traverse(void)
	{
	if ( list == 0 ) return 0;

	if ( start_flag == False )
		{
		pointer = list;
		start_flag = True;
		return list->val;
		}

	pointer = pointer->next;

	if ( pointer == 0 )
		{
		start_flag = False;
		return 0;
		}

	return pointer->val;
	}




#endif
#define PLIST/*
	sglobal.h

	global constants
*/

#ifndef GLOBAL

#define P_INFINITY 0x7fffffffL  // positive infinity
#define N_INFINITY 0			// negative infinity

typedef enum { False, True } Boolean;
typedef enum { Constant, Linear, Quadratic } Piecewise_Type;
typedef enum { Constant_Int, Constant_Float, Constant_String,
Constant_Binary, Constant_Time, Constant_Duration,
					Timelist_Int, Timelist_Float, Timelist_String, Timelist_Binary,
					Durlist_Int, Durlist_Float,
					List_Int, List_Float, List_String, List_Binary } Res_Val_Type;
typedef enum { Avail, Used, Original } Attribute;
typedef enum { Less, LessEqual, Equal, GreaterEqual, Greater } Match_Value;
typedef enum { And, Or } Binary_Operator;

#define Day 86400
#define Hour 3600
#define Minute 60


#endif

#define GLOBAL/*
	Schedule.h

	This basically holds a list of Actvities along with read and write routines
for IO.

*/

#include "miscio.h"
#include "plist.h"
#include "duration.h"
#include "activity.h"


class Schedule : public Misc_IO
	{
	public:
		Schedule()
			{
			loa = new PList<Activity*>();
			};

		~Schedule()
			{
			delete loa;
			};

		Activity* Append_Activity(const String& name)
			{
			Activity* act = new Activity(name);
			loa->Append(act);
			return act;
			};

		Activity* Find(const String& name)
			{
			Activity *act,*retval = 0;

			while ( act = loa->Traverse() )
				if ( name == act->Name() )
					retval = act;

			return retval;
			};

		Activity* Traverse(void)
			{
			return loa->Traverse();
			};

		int Number_Of_Activities(void)
			{
			return loa->Length();
			};

		String Version(void)
			{
			return version;
			};

		friend ostream& operator<<(ostream& os, Schedule* sched)
			{
			Activity* act;

			while ( act = sched->Traverse() )
				os << act;

			return os;
			};

		Boolean Load(const String& filename)
			{
			ifstream input (filename.Get(),ios::in);
			if ( !input ) return False;

			Boolean done = False;
			int choice = -1;
			String token;
			String s;
			int i;
			Activity* act;
			Duration dur;
			String stemp;
			Time start;
			char c[6];

// rcps dataset version 1 - 03/08/95
// Just read in the first six tokens, append these, and make them the version

			for ( i=0 ; i<6 ; i++ )
				{
				Get(input,token);
				version += token;
				version += " ";
				}

			while ( !done )
				{
				token = "\0";
				if ( !Get(input,token) ) done = True;

				if ( token == "/*" ) // ignore comments
					{
					while ( Get(input,token) && token != "*/" );
					choice = -1;
					}

				if ( token == "section1" )
					choice = 0;
				else if ( token == "section2" )
					choice = 1;
				else if ( token == "section3" )
					choice = 2;
				else if ( token == "section4" )
					choice = 3;
				else if ( token == "section5" )
					choice = 4;
				else
					{
					if ( choice == 0 )
						{
						act = Append_Activity(token);
						Get(input,s);
						dur = s;
						act->Requested_Duration(dur);

						for ( i = 1 ; i <= 17 ; i++ )
							{
							Get(input,s);
							act->Append_Resource(s.Atoi());
							}
						}
					else if ( choice == 1 )
						{
						Get(input,s);

						act = Find(s);
						if ( act ) act->Append_Pred(token);
						}
					else if ( choice == 2 )
						{
						Get(input,s);
						act = Find(token);

						start = "00:00:00 01Jan95";  // kluge, make this the start of the horizon

// The start of the scheduling horizon is 00:00:00 01Jan95
// Shift one is from 08:00:00 to 15:30:00
// Shift two is from 16:00:00 to 23:30:00

						if ( s[1] == '/' )
							{
							start = start.Ticks() + (long int)(s[0]-'0')*86400L;
							if ( s[2] == '1' )
								start = start.Ticks() + 8L*3600L;
							if ( s[2] == '2' )
								start = start.Ticks() + 16L*3600L;
							c[0] = s[4];
							c[1] = s[5];
							c[2] = s[6];
							c[3] = s[7];
							c[4] = s[8];
							c[5] = '\0';
							stemp = c;
							dur.Set(stemp);
							start = start + dur;
							}
						else if ( s[2] == '/' )
							{
							start = start.Ticks() + (long int)(s[0]-'0')*10L*86400L + (long
int)(s[0]-'0')*86400L;
							if ( s[3] == '1' )
								start = start.Ticks() + 8L*3600L;
							if ( s[3] == '2' )
								start = start.Ticks() + 16L*3600L;
							c[0] = s[5];
							c[1] = s[6];
							c[2] = s[7];
							c[3] = s[8];
							c[4] = s[9];
							c[5] = '\0';
							stemp = c;
							dur.Set(stemp);
							start = start + dur;
							}
						act->Start(start);
						}
					}
				}

			input.close();
			return True;
			};


/*
	This function places the data in a format readable by my SchedulerFive.  I
implemented a
	generic database for storage of most scheduling attributes in
SchedulerFive.  Slow, but easy.
*/

		Boolean Save_In_Ringer_Format(const String& filename, Boolean labor =
True, Boolean zones = True)
			{
			ofstream output (filename.Get(),ios::out);
			if ( !output ) return False;

			Activity* act;
			int ires;
			Duration dur;
			String name;

			output << "\n~Filename " << filename;

			while ( act = Traverse() )
				{
				output << "\n\n~Activity cs " << act->Name();

				dur = act->Requested_Duration();

// The real usage of a traverse would be
// 			while ( act->Traverse(ires) )
//					{
//					some code..
//					}

				act->Traverse_Resources(ires);
				if ( ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr0";
					output << "\n\t\t~~~Requirements ls name == labor.px ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}


				output << "\n\t~~Minimum_Execution_Duration cd " << dur;
				output << "\n\t~~Earliest_Start_Time ct 00:00:00 01Jan95";
				output << "\n\t~~Fox_Start_Time ct " << act->Start();

				act->Traverse_Resources(ires);
				if ( labor == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr1";
					output << "\n\t\t~~~Requirements ls name == labor.py ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( labor == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr2";
					output << "\n\t\t~~~Requirements ls name == labor.pz ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( labor == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr3";
					output << "\n\t\t~~~Requirements ls name == labor.pw ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( zones == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr4";
					output << "\n\t\t~~~Requirements ls name == ac_1_zone.za ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( zones == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr5";
					output << "\n\t\t~~~Requirements ls name == ac_1_zone.zb ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( zones == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr6";
					output << "\n\t\t~~~Requirements ls name == ac_1_zone.zc ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( zones == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr7";
					output << "\n\t\t~~~Requirements ls name == ac_1_zone.zd ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( zones == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr8";
					output << "\n\t\t~~~Requirements ls name == ac_1_zone.ze ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( zones == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr9";
					output << "\n\t\t~~~Requirements ls name == ac_1_zone.zf ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( zones == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr10";
					output << "\n\t\t~~~Requirements ls name == ac_1_zone.zg ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( zones == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr11";
					output << "\n\t\t~~~Requirements ls name == ac_1_zone.zh ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( zones == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr12";
					output << "\n\t\t~~~Requirements ls name == ac_1_zone.zi ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( zones == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr13";
					output << "\n\t\t~~~Requirements ls name == ac_1_zone.zj ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( zones == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr14";
					output << "\n\t\t~~~Requirements ls name == ac_1_zone.zk ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( zones == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr15";
					output << "\n\t\t~~~Requirements ls name == ac_1_zone.zl ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires);
				if ( zones == True && ires != 0 )
					{
					output << "\n\t~~Resource_Request cs rr16";
					output << "\n\t\t~~~Requirements ls name == ac_1_zone.zm ;";
					output << "\n\t\t~~~Effects ls avail -= " << ires << " for " << dur <<
" ;";
					}

				act->Traverse_Resources(ires); // this should be false, done just to
reset the list

				if ( act->Number_Of_Preds() > 0 )
					{
					output << "\n\t~~Preds ls ";
					while ( act->Traverse_Preds(name) )
						output << name << " ";
					output << ";";
					}

				}

			output << "\n\nEnd";

			output.close();
			return True;
			}

	private:

		PList<Activity*>* loa;  // list_of_activities
		String version;


	};
/*

	Activity.h


	This is a generic Activity class generated specifically for the Fox/Ringer
	Benchmark Data set.

	Each activity includes 5 attributes.

	1)  A start time (this is for the problems 5,6 and beyond)
	2)  The name of the activity
	3)  A duration of the activity
	4)  A list of Predecessors (in string format)
	5)  A list of resources in an integer list format.
			these are in the order labor.px, py,pz,pw, xone.za, zb, zc ...

	Accessor functions are available for each attribute.
*/


#include "mytime.h"
#include "mystring.h"
#include "list.h"


class Activity
	{
	public:

	Activity(const String& newname)
		{
		name = newname;
		lop = new List<String>();
		lor = new List<int>();
		};

	~Activity()
		{
		delete lop;
		};

	friend ostream& operator<<(ostream& os, Activity* act)
		{
		String name;
		int ires;

		os << "\n" << act->Name();
		os << "\n  Duration " << act->Requested_Duration();

		os << "\n  Resources ";
		while ( act->Traverse_Resources(ires) )
			os << ires << " ";

		os << "\n  Preds ";
		while ( act->Traverse_Preds(name) )
			os << name << " ";

		return os;
		};


	void Append_Pred(const String& predname)
		{
		lop->Append(predname);
		};

	Boolean Traverse_Preds(String& predname)
		{
		return lop->Traverse(predname);
		};

	int Number_Of_Preds(void)
		{
		return lop->Length();
		};

	void Append_Resource(int ires)
		{
		lor->Append(ires);
		};

	Boolean Traverse_Resources(int& ires)
		{
		return lor->Traverse(ires);
		};

	void Name(const String& newname)
		{
		name = newname;
		};

	String Name(void)
		{
		return name;
		};

	void Start(const Time& newstart)
		{
		start = newstart;
		};

	Time Start(void)
		{
		return start;
		};

	void Requested_Duration(const Duration& newdur)
		{
		duration = newdur;
		};

	Duration Requested_Duration(void)
		{
		return duration;
		};

	private:

		Time start;
		String name;
		Duration duration;
		List<String>* lop;  // list_of_predecessors
		List<int>* lor;  // list_of_resources

	};


/*
	bench.cpp

	Benchmark Conversion routines scheduler

	Built:  12 Dec 1994

	Only, activity.h, schedule.h, and bench.cpp are new
*/


#include "schedule.h"

// for bookkeeping information...
long int nsc,nsd,ntc,ntd,ndc,ndd,ntlc,ntld,ndlc,ndld,xcount,ycount;


int main()
	{
	cout << "Begin";

	Schedule* sched = new Schedule();
	sched->Load("rcps.dat");
	cout << "\nMiddle";
	sched->Save_In_Ringer_Format("rcps2i.act");

	cout << "\nEnd";

	return 1;
	}
/*
	Duration.cpp

	Routines for keeping track of durations.  I define a duration as a relative
time.  This is a time that
	has no anchor.  For example, 3 hours is a duration.  10 o'clock on the 15th
of december 1993 is 
	an (absolute) time.

*/


#ifndef GLOBAL
#include "sglobal.h"
#endif

#ifndef DURATION
#include "duration.h"
#endif

extern long int ndc,ndd;

Duration::Duration()
	{
	ticks = 0;
    ndc++;
	}

Duration::Duration(const Duration& d0)
	{
	ticks = d0.Ticks();
	ndc++;
    }

Duration::Duration(long int li)
	{
	ticks = li;
    ndc++;
	}

Duration::Duration(const String& s)
	{
	Set(s);
    ndc++;
	}

Duration::~Duration(void)
	{
	ndd++;
    }

ostream& operator<<(ostream& os, const Duration& d0)
	{
	if ( d0.Ticks() == P_INFINITY ) os << "+infinity";
	else if (d0.Ticks() == N_INFINITY) os << "00:00:00 0days";
	else
       	{
		os << d0.Get();
		os << " " << d0.Ticks()/86400L << "days";
		}
	return os;
	}


istream& operator>>(istream& is, Duration& d0)
	{
	String s0,s2;
	char c[4];
	long int li;
    Boolean error = False;
	c[2] = '\0';
    c[3] = '\0';

	do
		{
		error = False;
		is >> s0;

        error = d0.Set(s0.Car()); // was time

		s2 = s0.Cdr();

		if ( error == False )
          	{
			if ( s2 != 0 &&
				(s2[1] == 'd' || s2[1] == 'D' || s2[2] == 'd' || s2[2] == 'D' || s2[3]
== 'd' || s2[3] == 'D' || s2[3] == 'd' || s2[3] == 'D' || s2[4] == 'd' ||
s2[4] == 'D' || s2[5] == 'd' || s2[5] == 'D' || s2[6] == 'd' || s2[6] == 'D') &&
				( s2[2] == 'a' || s2[2] == 'A' || s2[3] == 'a' || s2[3] == 'a' || s2[4]
== 'a' || s2[4] == 'A' || s2[5] == 'a' || s2[5] == 'A' || s2[6] == 'a' ||
s2[6] == 'A' || s2[7] == 'a' || s2[7] == 'A') )
				{
				li = s2.Atol();
				if ( li < 0 || li > 77L*365L ) error = True;
				d0.ticks += li*86400L; // is this correct
				}
			}

		if ( error == True )
			{
			cout << "Please Re-enter ";
			d0 = 0;
			}

		} while ( error == True );

	return is;
	}

Boolean Duration::Set(const String& s)
	{
	Boolean error = False;
	char c[4];
	c[2] = '\0';
	c[3] = '\0';
	int i;
	String s1,sd;

	s1 = s.Car();
	sd = s.Cdr();


	if ( s1.Check_Time() )
		{
		error = True;
		}
	else if ( s1.Atoi() > 23 || s1.Atoi() < 0 /*|| s1 == 0*/ || s1.Length() > 8)
		{
		error = True;
		}
	else if ( s1.Length() == 1 || s1.Length() == 2 || s1.Length() == 3 )
		{
		if ( s1.Atoi() < 0 || s1.Atoi() > 23 ) error = True;
		ticks = s1.Atoi()*3600L;
		  }
	else if ( s1[2] == ':' && s1[5] == ':')
		{
		c[0] = s1[0];
		c[1] = s1[1];
		  c[2] = '\0';
		i = atoi(c);
  	    if ( i < 0 || i > 23 ) error = True;
		ticks = i*3600L;
                    	
		c[0] = s1[3];
		c[1] = s1[4];
        c[2] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 59 ) error = True;
		ticks += i*60;

		c[0] = s1[6];
		c[1] = s1[7];
        c[2] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 59 ) error = True;
		ticks += i;

		  if ( s1.Length() > 8 ) error = True;
		}
	else if ( s1[1] == ':' && s1[4] == ':')
		{
		c[0] = s1[0];
       	c[1] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 23 ) error = True;
		ticks = i*3600L;
            	
		c[0] = s1[2];
		c[1] = s1[3];
        c[2] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 59 ) error = True;
		ticks += i*60;

		c[0] = s1[5];
		c[1] = s1[6];
		  c[2] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 59 ) error = True;
		ticks += i;

		if ( s1.Length() > 7 ) error = True;
		}
	else if ( s1[2] == ':' )
		{
		c[0] = s1[0];
		c[1] = s1[1];
        c[2] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 23 ) error = True;
		ticks = i*3600L;

		c[0] = s1[3];
		c[1] = s1[4];
        c[2] = '\0';
		  i = atoi(c);
		if ( i < 0 || i > 59 ) error = True;
		ticks += i*60;

		  if ( s1.Length() > 5 ) error = True;
		}
	else if ( s1[1] == ':' )
		{
		c[0] = s1[0];
			 c[1] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 23 ) error = True;
		ticks = i*3600L;

		c[0] = s1[2];
		c[1] = s1[3];
		  c[2] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 59 ) error = True;
		ticks += i*60;

		  if ( s1.Length() > 4 ) error = True;
		}

	ticks += (long int)sd.Atoi()*86400L;   // a problem with Atoi will return 0

	return error;
	 }

String Duration::Get(void) const
	{
	long int d0;
	int hours = 0,
		minutes = 0,
		seconds = 0;
	String retval;
	char ct[9];

	d0 = ticks;

	while ( d0 >= 86400L*365 )
		{
		d0 -= 86400L*365;
		};

	while ( d0 >= 86400L )
		{
		d0 -= 86400L;
		};

	while ( d0 >= 3600 )
		{
        hours++;
		d0 -= 3600;
		};

	while ( d0 >= 60 )
		{
		minutes++;
		d0 -= 60;
		};

	seconds = (int)d0;

	if ( hours < 10 )
		{
		ct[0] = '0';
		ct[1] = '0' + hours;
		}
	else
		{
		ct[0] = '0' + hours/10;
		ct[1] = '0' + hours - (hours/10)*10;
		}

	if ( minutes < 10 )
		{
		ct[3] = '0';
		ct[4] = '0' + minutes;
		}
	else
		{
		ct[3] = '0' + minutes/10;
		ct[4] = '0' + minutes - (minutes/10)*10;
		}

	if ( seconds < 10 )
		{
		ct[6] = '0';
		ct[7] = '0' + seconds;
		}
	else
		{
		ct[6] = '0' + seconds/10;
		ct[7] = '0' + seconds - (seconds/10)*10;
		}

	ct[2] = ':';
	ct[5] = ':';

	ct[8] = '\0';

	retval = ct;
    return retval;
	}


 long int Duration::Ticks(void) const
	{
    return ticks;
	}

Duration& Duration::operator=( long int li )
	{
	if ( li < 0 ) ticks = 0;
	else ticks = li;
    return *this;
	}

Duration& Duration::operator=( const Duration&  d0)
	{
	if ( d0.Ticks() < 0 ) ticks = 0;
	else ticks = d0.Ticks();
    return *this;
	}

Duration& Duration::operator+=( const Duration&  d0 )
	{
	ticks += d0.Ticks();
	if ( ticks < 0 )
		{
        cout << "\nDuration::operator+= OVERFLOW";
		ticks = P_INFINITY;
		}
    return *this;
	}

Duration& Duration::operator-=( const Duration&  d0 )
	{
	ticks -= d0.Ticks();
	if ( ticks < 0 )
		{
        cout << "\nDuration::operator-= UNDERFLOW";
		ticks=N_INFINITY;
		}
    return *this;
	}

Duration Duration::operator+( const Duration&  d0 ) const
	{
	if ( ticks + d0.Ticks() < 0 )
		{
        cout << "\nDuration::operator+ OVERFLOW";
		return P_INFINITY;
        }
	return ticks + d0.Ticks();
	}

Duration Duration::operator-( const Duration&  d0 ) const
	{
	if ( ticks - d0.Ticks() < 0 )
		{
        cout << "\nDuration::operator- UNDERFLOW";
		return 0;
        }
	return ticks - d0.Ticks();
	}

Boolean Duration::operator!=( const Duration&  d0  ) const
	{
	if ( ticks != d0.Ticks() ) return True;
	else return False;
	}

Boolean Duration::operator==( const Duration&  d0 ) const
	{
	if ( ticks == d0.Ticks() ) return True;
	else return False;
	}

Boolean Duration::operator>( const Duration&  d0 ) const
	{
	if ( ticks > d0.Ticks() ) return True;
	else return False;
	}

Boolean Duration::operator>=( const Duration&  d0 ) const
	{
	if ( ticks >= d0.Ticks() ) return True;
	else return False;
	}

Boolean Duration::operator<( const Duration&  d0 ) const
	{
	if ( ticks < d0.Ticks() ) return True;
	else return False;
	}

Boolean Duration::operator<=( const Duration&  d0 ) const
	{
	if ( ticks <= d0.Ticks() ) return True;
	else return False;
	}

Boolean Duration::Inside(const Duration& d0, const Duration& d1) const
	{
	if ( ticks >= d0.Ticks() && ticks < d1.Ticks() )
		return True;
	else
		return False;
	}
/*
	miscio.cpp

	File IO routines

*/

#include "miscio.h"



Boolean Misc_IO::Get(ifstream& input, String& s)
	{
	char ch;
	int count = 0;
	char string[80];
    Boolean done = True;

	while ( done && input.get(ch) )
		{
		if ( ch == EOF ) return False;

		if ( !(( ch == ' ' || ch == '\t' || ch == '\n' ) && count == 0) ) // takes
care of multiple delimiters
			{
			if ( ch == ' ' || ch == '\t' || ch == '\n' )
				{
        	   	string[count++] = '\0';
				count = 0;
				done = False;
				}
			else
				{
				string[count++] = ch;
				}
			}
		}

	if ( ch == EOF ) return False;

	s = string;

	return True;
    }
/*
	mystring.cpp

	A String class.
*/

#include "mystring.h"
#include <string.h>
#include <ctype.h>

extern long int nsc,nsd,ycount;

String::String()
	{
	string = new char[1];
	string[0] = '\0';
	nsc++;
	}

String::String(char* new_string)
	{
	string = new char[strlen(new_string)+1];
	strcpy(string,new_string);
	nsc++;
	}

String::String(int intchar)
	{
	string = new char[8];
	itoa(intchar,string,10);
	nsc++;
	}

String::String(long int lintchar)
	{
	string = new char[10];
	ltoa(lintchar,string,10);
	nsc++;
	}

String::String(float fchar)
	{
	string = new char[10];
	gcvt(fchar,3,string);
	nsc++;
	}

String::String(const String& s)
	{
	string = new char[s.Length()+1];
	if ( s.Length() == 0 ) string[0] = '\0';
	else strcpy(string,s.Get());
	nsc++;
	}

String::~String()
	{
	if ( string != 0 )
		{
		delete [] string;
		string = 0;
		}
	nsd++;
	}


ostream& operator<<(ostream& os, const String& s0)
	{
	os << s0.Get();
	return os;
	}

istream& operator>>(istream& is, String& s0)
	{
	char* c = new char[80];

	is.getline(c,80);
	s0 = c;

	delete [] c;

	return is;
	}


char* String::Get(void) const
	{
	return string;
	}

Res_Val_Type String::Constant_Type(void)
	{
	int i;
	Boolean point = False;
	Boolean number = False;
	Boolean letter = False;

	for ( i=0 ; i<Length() ; i++ )
		{
		if ( string[i] >= '0' && string[i] <= '9' ) number = True;
		if ( (string[i] >= 'a' && string[i] <= 'z') || (string[i] >= 'A' &&
string[i] <= 'Z')) letter = True;
		if ( string[i] == '.' ) point = True;
		}

	if ( letter == True ) return Constant_String;
	if ( number == True && point == True ) return Constant_Float;
	if ( number == True && point == False ) return Constant_Int;

	return Constant_String;
	}


void String::operator=(char* new_string)
	{
	delete [] string;
	string = new char[strlen(new_string)+1];
	strcpy(string,new_string);
    }

String& String::operator+=(const String& new_string)
	{
	int length = strlen(string)+new_string.Length();
	if ( string != 0 )
    	{
		char *temp = new char[strlen(string)+1];
		strcpy(temp,string);
		delete [] string;
		string = new char[length+1];
		strcpy(string,temp);
	    strcat(string,new_string.Get());
		}
	else
		{
		string = new char[new_string.Length()+1];
		strcpy(string,new_string.Get());
		  }
	return *this;
	}

String operator+(const String& s0, const String& s1)
	{
	String result = s0;
	result += s1;
	return result;
	}


String& String::operator=(const String& new_string)
	{
	delete [] string;
	string = new char[strlen(new_string.Get())+1];
	strcpy(string,new_string.Get());
	return *this;
	 }

String& String::operator=(int intchar)
	{
	delete [] string;
	 string = new char[10];
	 itoa(intchar,string,10);
	return *this;
	}

void String::Set(const String& new_string)
	{
	delete [] string;
	string = new char[strlen(new_string.Get())+1];
	strcpy(string,new_string.Get());
	}


String& String::operator=(long int longintchar)
	{
	delete [] string;
	 string = new char[10];
	ltoa(longintchar,string,10);
	return *this;
	}

Boolean String::Compare(const String& other_string, int number) const
	{
	if ( !strncmp(string,other_string.Get(),number) ) return True;
		else return False;
	}

int String::Length(void) const
	{
	return strlen(string);
	}

void String::Convert(int& i)
	{
	i = atoi(string);
	}

void String::Convert(long int& li)
	{
	li = atol(string);
	}

void String::Convert(double& d)
	{
	d = atof(string);
	}

void String::Convert(long double& ld)
	{
	ld = _atold(string);
	}


int String::Atoi(void) const
	{
	return atoi(string);
	}

long int String::Atol(void) const
	{
	return atol(string);
	}

float String::Atof(void) const
	{
	return atof(string);
	}

long double String::Atold(void) const
	{
	return _atold(string);
	}

char& String::operator[](int i)
	{
	if ( i >= 0 && i < Length() ) return string[i];
		else return string[0];
    }

char String::operator[](int i) const
	{
	if ( i >= 0 && i < Length() ) return string[i];
		else return 0;
    }

Boolean String::operator==(const String& other_string) const
	{
	ycount++;
	if ( !strcmpi(string,other_string.Get()) ) return True;
		else return False;
	}

Boolean String::operator==(long int other) const
	{
	ycount++;
	 char s[80];
	 ltoa(other,s,10);
	if ( !strcmpi(string,s) ) return True;
		else return False;
	}

Boolean String::operator==(const char* other) const
	{
	ycount++;
	if ( !strcmpi(string,other) ) return True;
		else return False;
	}

Boolean String::operator!=(const String& other_string) const
	{
	if ( strcmpi(string,other_string.Get()) ) return True;
		else return False;
	}

Boolean String::operator>(const String& other_string) const
	{
	if ( strcmpi(string,other_string.Get()) > 0 ) return True;
		else return False;
	}

Boolean String::operator<(const String& other_string) const
	{
	if ( strcmpi(string,other_string.Get()) < 0 ) return True;
		else return False;
	}

Boolean String::operator>=(const String& other_string) const
	{
	if ( strcmpi(string,other_string.Get()) >= 0 ) return True;
		else return False;
	}

Boolean String::operator<=(const String& other_string) const
	{
	if ( strcmpi(string,other_string.Get()) <= 0 ) return True;
		else return False;
	}


Boolean String::Check_Time(void) const
	{
	int i;

	for ( i=0 ; i<Length() ; i++ )
		{
		if ( string[i] < '0' || string[i] > '9' )
			{
			if ( string[i] != ':' ) return True;
			}
		}


	if ( Length() == 8 && string[2] != ':' && string[5] != ':' ) return True;

	if ( Length() == 7 && string[1] != ':' && string[4] != ':' ) return True;

	if ( Length() == 5 && string[2] != ':' ) return True; 

	if ( Length() == 4 && string[1] != ':' ) return True;

	int count=0;

	for ( i=0 ; i<Length() ; i++ )
		{
		if ( string[i] == ':' ) count++;
		}

	if ( count > 2 ) return True;

	return False;
	}


String String::First(void) const
	{
	return Car();
	}


String String::Second(void) const
	{
	return Cdr().Car();
	}

String String::Third(void) const
	{
	return Cdr().Cdr().Car();
	}

String String::Fourth(void) const
	{
	return Cdr().Cdr().Cdr().Car();
	}

String String::Fifth(void) const
	{
	return Cdr().Cdr().Cdr().Cdr().Car();
	}

String String::Sixth(void) const
	{
	return Cdr().Cdr().Cdr().Cdr().Cdr().Car();
	}

String String::Seventh(void) const
	{
	return Cdr().Cdr().Cdr().Cdr().Cdr().Cdr().Car();
	}

String String::Car(void) const
	{
	int i=0;
	String s;
	char *c = new char[Length()+1];

	while ( i <= Length() )
		{
		if ( string[i] == ' ' || string[i] == '\0' || string[i] == '\n' )
			{
			strncpy(c,string,i);
			c[i] = '\0';
			s = c;
            delete [] c;
			return s;
			}
		else
			i++;
		}

	delete [] c;
	return 0;
	}


String String::Cdr(void) const
	{
	int i=0,start=0;
	 Boolean flag = False;
	String s;
	char *c = new char[Length()+1];

	while ( i <= Length() )
		{
		if ( flag == False && (string[i] == ' ' || string[i] == '\0' || string[i]
== '\n') )
				{
			flag = True;
			while ( string[++i] == ' ' );
			start = i;
			}
		else
			{
			if ( string[i] == ' ' || string[i] == '\0' || string[i] == '\n' )
				{
				int j;
				for ( j=start ; j<Length()+1 ; j++ )
					c[j-start] = string[j];
				s = c;
				delete [] c;
				return s;
				}
			else
				i++;
				}
		}

	 delete [] c;
	return 0;
	}

int String::Tokens(void) const
	{
	int i=0,count=0;

	while ( i <= Length() )
		{
		if ( string[i] == ' ' || string[i] == '\0' )
			{
			while ( string[++i] == ' ' || string[i] == '\0' );
			count++;
			}
		else
			i++;
		}
	return count;
	}


void String::To_Lower(void)
	{
	int i;

	for (i=0; i<Length(); i++)
		{
		string[i] = tolower(string[i]);
		}

	return;
	}



String String::Make_Underscores_Spaces(void) const
	{
	String str;
	if ( Length() == 0 ) return str;
	char* c = new char[Length()+1];

	for ( int i = 0 ; i<Length() ; i++ )
		{
		if ( string[i] == '_' )
			c[i] = ' ';
        else
			c[i] = string[i];
		}

	c[Length()] = '\0';

	str = c;

    delete [] c;
	return str;
	}
			 



/*
	Mytime.cpp

	Routines for keeping track of time.  These are (absolute) times.  I
consider an absolute Time
	to have an anchor.  That is, 3 hours is not a Time, it has no anchor.
12:00:00 on the 13th of 
	December 1993 is an absolute time.

*/

extern long int ntc,ntd,xcount;

#include <stdio.h>
#include <string.h>

#ifndef GLOBAL
#include "sglobal.h"
#endif

#ifndef MYTIME
#include "mytime.h"
#endif



Time::Time()
	{
	ticks = 0;
    ntc++;
	}

Time::Time(const Time& t0)
	{
	ticks = t0.Ticks();
	ntc++;
	}

Time::Time(long int t0)
	{
	ticks = t0;
    ntc++;
	}

Time::Time(int t0)
	{
	ticks = t0;
    ntc++;
	}

Time::Time(const String& s)
	{
	Set_Time(s.Car());
	Set_Date(s.Cdr());
    ntc++;
	}

Time::~Time(void)
	{
	ntd++;
	}

Boolean Time::Set(const String& s)
	{
	if ( Set_Time(s.Car()) || Set_Date(s.Cdr()) ) return True;
		else return False;
	}

Boolean Time::Set(const String& s0, const String& s1)
	{
	if ( Set_Time(s0) || Set_Date(s1) ) return True;
		else return False;
	}


ostream& operator<<(ostream& os, const Time& t0)
	{
	Time t1=t0;

	if ( t1 == 0 ) os << "-infinity";
	else if ( t1 == P_INFINITY ) os << "+infinity";
	else
       	{
		os << t1.Get() << " " << t1.Day_Of_Week();
		}
	return os;
	}


String Time::Day_Of_Week(void) const
	{
	long int days = ticks/86400L%7;

	if ( days == 6 ) return "Sun";
	else if ( days == 0 ) return "Mon";
	else if ( days == 1 ) return "Tue";
	else if ( days == 2 ) return "Wed";
	else if ( days == 3 ) return "Thu";
	else if ( days == 4 ) return "Fri";
	else return "Sat";
	}

Boolean Time::Daylight_Savings(void) const
	{
	Time start,end;
	start = "02:00:00 04Apr93";
	end = "02:00:00 31Oct93";
	if ( Inside(start,end) ) return True;

	start = "02:00:00 03Apr94";
	end = "02:00:00 30Oct94";
	if ( Inside(start,end) ) return True;

	start = "02:00:00 02Apr95";
	end = "02:00:00 29Oct95";
	if ( Inside(start,end) ) return True;

	start = "02:00:00 07Apr96";
	end = "02:00:00 27Oct96";
	if ( Inside(start,end) ) return True;

	start = "02:00:00 06Apr97";
	end = "02:00:00 26Oct97";
	if ( Inside(start,end) ) return True;

	start = "02:00:00 05Apr98";
	end = "02:00:00 25Oct98";
	if ( Inside(start,end) ) return True;

	return False;
    }


istream& operator>>(istream& is, Time& t0)
	{
	String s0;
	Boolean error = False;

	do
		{
		t0 = 0;
		error = False;
		is >> s0;

		if ( s0 == "" )
			{
			t0 = 0;
			return is;
            }

		if ( t0.Set_Time(s0.Car()) || t0.Set_Date(s0.Cdr()) ) error = True;

		if ( error == True )
			{
			cout << "Please Re-enter ";
			t0 = 0;
			}
		} while ( error == True );

	return is;
	}



String Time::Get(void) const
	{
	long int t0, temp_t0;
	int hours = 0,
		minutes = 0,
		seconds = 0;
	int days = 0,
		years = 0;
	char ct[9];
	char cd[8];
	char retval[17];
    String retstr;

    t0 = ticks;

    temp_t0 = t0; // so t0 doesn't change!

	while( temp_t0 >= 31536000L)  // to calculate years from t0
		{						  // **** changed to >= *****
		years++;
		temp_t0-=31536000L;
		if((1990+years)%4==0)
            temp_t0-=86400L;
        }
        	
//	cout <<"Diagnostic:\n";
//	cout << "Year:" << years << "\n";
//	cout << "t0:" << t0 << "\n";

	if(((1990+years)%4)==0)
		t0-=(86400L*365*years+((((1990+years)/4)-498)*86400L)); // algorithm for
detecting leap years
	else t0-=(86400L*365*years+((((1990+years)/4)-497)*86400L)); // algorithm
for detecting leap years

	


	while ( t0 >= 86400L )
		{
		days++;
		t0 -= 86400L;
		};

	while ( t0 >= 3600 )
		{
		hours++;
		t0 -= 3600;
		};

	while ( t0 >= 60 )
		{
		minutes++;
		t0 -= 60;
		};

	seconds = (int)t0;

	if ( hours < 10 )
		{
		ct[0] = '0';
		ct[1] = '0' + hours;
		}
	else
		{
		ct[0] = '0' + hours/10;
		ct[1] = '0' + hours - (hours/10)*10;
		}

	if ( minutes < 10 )
		{
		ct[3] = '0';
		ct[4] = '0' + minutes;
		}
	else
		{
		ct[3] = '0' + minutes/10;
		ct[4] = '0' + minutes - (minutes/10)*10;
		}

	if ( seconds < 10 )
		{
		ct[6] = '0';
		ct[7] = '0' + seconds;
		}
	else
		{
		ct[6] = '0' + seconds/10;
		ct[7] = '0' + seconds - (seconds/10)*10;
		}

	ct[2] = ':';
	ct[5] = ':';

	char char_date[3];
	int int_days = 0;
	int i;
	int month_counter = 0;
	int total_days[12] = {30,58,89,119,150,180,211,242,272,303,333,364};
	int total_leap_days[12] = {30,59,90,120,151,181,212,243,273,304,334,365};
	Boolean leap_flag=False;

	if((1990+years)%4==0) // sets leap_flag if currently in leap year
		leap_flag=True;

	years += 90;

	if ( years > 99 ) years -= 100;


	if ( days <= 30 )
		month_counter = 0;
		

	if(leap_flag) // gets month in leap year else normal year
		for ( i=1 ; i<12 ; i++)
            {
			if ( days > total_leap_days[i-1] && days <= total_leap_days[i] )
				month_counter = i;
			}
	else
		for ( i=1 ; i<12 ; i++)
            {
            if ( days > total_days[i-1] && days <= total_days[i] )
		 		month_counter = i;
			}

	if(leap_flag)  // gets days in leap year else normal year
        {
		if ( month_counter != 0 )
			int_days = days - total_leap_days[month_counter-1];
		else int_days = days + 1;
		}

	else
    	{
		if ( month_counter != 0 )
			int_days = days - total_days[month_counter-1];
		else int_days = days + 1;
		}

	if ( month_counter == 0 ) {			cd[2] = 'J'; cd[3] = 'a'; cd[4] = 'n'; }
	else if ( month_counter == 1 ) {	cd[2] = 'F'; cd[3] = 'e'; cd[4] = 'b'; }
	else if ( month_counter == 2 ) {	cd[2] = 'M'; cd[3] = 'a'; cd[4] = 'r'; }
	else if ( month_counter == 3 ) {	cd[2] = 'A'; cd[3] = 'p'; cd[4] = 'r'; }
	else if ( month_counter == 4 ) { 	cd[2] = 'M'; cd[3] = 'a'; cd[4] = 'y'; }
	else if ( month_counter == 5 ) {	cd[2] = 'J'; cd[3] = 'u'; cd[4] = 'n'; }
	else if ( month_counter == 6 ) {	cd[2] = 'J'; cd[3] = 'u'; cd[4] = 'l'; }
	else if ( month_counter == 7 ) {	cd[2] = 'A'; cd[3] = 'u'; cd[4] = 'g';	}
	else if ( month_counter == 8 ) {	cd[2] = 'S'; cd[3] = 'e'; cd[4] = 'p'; }
	else if ( month_counter == 9 ) {	cd[2] = 'O'; cd[3] = 'c'; cd[4] = 't';	}
	else if ( month_counter == 10 ){	cd[2] = 'N'; cd[3] = 'o'; cd[4] = 'v';	}
	else if ( month_counter == 11 ){	cd[2] = 'D'; cd[3] = 'e'; cd[4] = 'c';	}

	if ( int_days <= 9 )
		{
		char_date[0] = '0';
		char_date[1] = int_days + '0';
		}
	else
		{
		sprintf(char_date,"%i",int_days);
		}

	strncpy(&cd[0],char_date,2);

	if ( years < 10 )
		{
		cd[5] = '0';
		cd[6] = '0' + years;
		}
	else
		{
		cd[5] = '0' + years/10;
		cd[6] = '0' + years - (years/10)*10;
		}

	cd[7] = '\0';
	ct[8] = '\0';


	for ( i=0 ; i<8 ; i++ ) retval[i] = ct[i];
	retval[8] = ' ';
	for ( i=0 ; i<7 ; i++ ) retval[i+9] = cd[i];
    retval[16] = '\0';

	retstr = retval;
    return retstr;
	}

Boolean Time::Set_Date(const String& s)
	{
	int days[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
    int leap_days[12]={ 31,29,31,30,31,30,31,31,30,31,30,31 };
	int date = s.Atoi();
	 int month=0,year,i;
    Boolean leap_flag = False;
	Boolean error = False;
	char ss[20];
	strcpy(ss,s.Get());
//    cout << "\nThis is the date according to Set_Date" << date << "\n";
//	cout << "This is the string ss from Set_Date:" << ss << "\n";

    char c[4];
	if ( s.Length() == 6 ) strncpy(c,&ss[1],3);
	else if ( s.Length() == 7 ) strncpy(c,&ss[2],3);
	else return True;
	c[3] = '\0';


	if ( !strcmpi(c,"Jan") ) month = 0;
	else if ( !strcmpi(c,"Feb") ) month = 1;
	else if ( !strcmpi(c,"Mar") ) month = 2;
	else if ( !strcmpi(c,"Apr") ) month = 3;
	else if ( !strcmpi(c,"May") ) month = 4;
	else if ( !strcmpi(c,"Jun") ) month = 5;
	else if ( !strcmpi(c,"Jul") ) month = 6;
	else if ( !strcmpi(c,"Aug") ) month = 7;
	else if ( !strcmpi(c,"Sep") ) month = 8;
	else if ( !strcmpi(c,"Oct") ) month = 9;
	else if ( !strcmpi(c,"Nov") ) month = 10;
	else if ( !strcmpi(c,"Dec") ) month = 11;
    else error = True;

	if ( error == True ) return True;


	if ( month == 0 && ( date < 1 || date > 31 ) ) error = True;
	else if ( month == 1 && ( date < 1 || date > 29 ) )	error = True;
	else if ( month == 2 && ( date < 1 || date > 31 ) ) error = True;
	else if ( month == 3 && ( date < 1 || date > 30 ) ) error = True;
	else if ( month == 4 && ( date < 1 || date > 31 ) ) error = True;
	else if ( month == 5 && ( date < 1 || date > 30 ) ) error = True;
	else if ( month == 6 && ( date < 1 || date > 31 ) ) error = True;
	else if ( month == 7 && ( date < 1 || date > 31 ) ) error = True;
	else if ( month == 8 && ( date < 1 || date > 30 ) ) error = True;
	else if ( month == 9 && ( date < 1 || date > 31 ) ) error = True;
	else if ( month == 10 && ( date < 1 || date > 30 ) ) error = True;
	else if ( month == 11 && ( date < 1 || date > 31 ) ) error = True;

	if ( s.Length() == 6 ) strncpy(c,&ss[4],2);
	else if ( s.Length() == 7 ) strncpy(c,&ss[5],2);
	else return False;
	c[3] = '\0';

	year = atoi(c);

	if(year%4==0)
        leap_flag=True;

    if(month == 1 && date == 29) // leap year calculations to see if valid
leap year was entered
		{
		if(leap_flag==True)
        	error = False;
    	else
			error = True;
		}
        
	if(leap_flag)
        {
	 	for ( i=0 ; i<month ;  i++ ) date += leap_days[i];
        date--;  // since we start at zero;
    	ticks += date*86400L;
        }
	else
		{
		for ( i=0 ; i<month ;  i++ ) date += days[i];
	    date--;  // since we start at zero;
		ticks += date*86400L;
        }

	

	if( year >=90 && year<100) year-=90;
	else if ( year>=0 && year<50) year+=10;
	else error = True;

	if(((1990+year)%4)==0)
       	ticks+=(86400L*365*year+((((1990+year)/4)-498)*86400L)); //
algorithm for detecting leap years
		
	else ticks+=(86400L*365*year+((((1990+year)/4)-497)*86400L)); // algorithm
for detecting leap years
	return error;
    }


Boolean Time::Set_Time(const String& s)
	{
	int i;
	Boolean error = False;
	char c[4];
	c[2] = '\0';
    c[3] = '\0';

	if ( s.Check_Time() )
		{
		error = True;
		}
	else if ( s.Atoi() > 23 || s.Atoi() < 0 || s.Length() > 8)
		{
		error = True;
		}
	else if ( s.Length() == 1 || s.Length() == 2 )
		{
		if ( s.Atoi() < 0 || s.Atoi() > 23 ) error = True;
		ticks = s.Atoi()*3600L;
        }
	else if ( s[2] == ':' && s[5] == ':')
		{
		c[0] = s[0];
		c[1] = s[1];
		c[2] = '\0';
		i = atoi(c);
   	    if ( i < 0 || i > 23 ) error = True;
		ticks = i*3600L;
                    	
		c[0] = s[3];
		c[1] = s[4];
        c[2] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 59 ) error = True;
		ticks += i*60;

		c[0] = s[6];
		c[1] = s[7];
        c[2] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 59 ) error = True;
		ticks += i;

        if ( s.Length() > 8 ) error = True; 
		}
	else if ( s[1] == ':' && s[4] == ':')
		{
		c[0] = s[0];
      	c[1] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 23 ) error = True;
		ticks = i*3600L;
           	
		c[0] = s[2];
		c[1] = s[3];
        c[2] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 59 ) error = True;
		ticks += i*60;

		c[0] = s[5];
		c[1] = s[6];
        c[2] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 59 ) error = True;
		ticks += i;

		if ( s.Length() > 7 ) error = True;
		}   	
	else if ( s[2] == ':' )
		{
		c[0] = s[0];
		c[1] = s[1];
        c[2] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 23 ) error = True;
		ticks = i*3600L;

		c[0] = s[3];
		c[1] = s[4];
        c[2] = '\0';
        i = atoi(c);
		if ( i < 0 || i > 59 ) error = True;
		ticks += i*60;

		if ( s.Length() > 5 ) error = True;
		}
	else if ( s[1] == ':' )
		{
		c[0] = s[0];
  	    c[1] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 23 ) error = True;
		ticks = i*3600L;

		c[0] = s[2];
		c[1] = s[3];
        c[2] = '\0';
		i = atoi(c);
		if ( i < 0 || i > 59 ) error = True;
		ticks += i*60;

		if ( s.Length() > 4 ) error = True;
		}

	return error;
    }



Time& Time::operator=( const Time& t0 )
	{
	ticks = t0.Ticks();
	 return *this;
	}

Time& Time::operator=( const String& s )
	{
	Set_Time(s.Car());
	Set_Date(s.Cdr());
	 return *this;
	}

Time& Time::operator=( long int li )
	{
	ticks = li;
	 return *this;
	}

Time& Time::operator+=( const Duration& d0 )
	{
	ticks += d0.Ticks();
	if ( ticks < 0 )
		{
        cout << "\nTime::operator+= OVERFLOW";
		ticks = P_INFINITY;
        }
    return *this;
	}

Time& Time::operator-=( const Duration& d0 )
	{
	ticks -= d0.Ticks();
	if ( ticks < 0 )
		{
        cout << "\nTime::operator-= UNDERFLOW";
		ticks = 0;
        }
	return *this;
	}

Time Time::operator+( const Duration& d0 ) const
	{
	if ( ticks + d0.Ticks() < 0 )
		{
        cout << "\nTime::operator+ OVERFLOW";
		return P_INFINITY;
        }
	return ticks + d0.Ticks();
	}

Time Time::operator-( const Duration& d0 ) const
	{
	if ( ticks - d0.Ticks() < 0 )
		{
		cout << "Time::operator- UNDERFLOW";
		return 0;
        }
	return ticks - d0.Ticks();
	}


Duration Time::operator-( const Time& t0) const
	{
	if ( ticks > t0.Ticks() )
		return ticks-t0.Ticks();
	else
		return 0;
	}

Boolean Time::operator!=( const Time& t0  ) const
	{
	if ( ticks != t0.Ticks() ) return True;
	else return False;
	}

Boolean Time::operator==( const Time& t0 ) const
	{
	if ( ticks == t0.Ticks() ) return True;
	else return False;
	}

Boolean Time::operator>=( const Time& t0 ) const
	{
	if ( ticks >= t0.Ticks() ) return True;
	else return False;
	}

Boolean Time::operator<( const Time& t0 ) const
	{
	if ( ticks < t0.Ticks() ) return True;
	else return False;
	}

Boolean Time::operator<=( const Time& t0 ) const
	{
	if ( ticks <= t0.Ticks() ) return True;
	else return False;
	}

Boolean Time::Inside(const Time& t0, const Time& t1) const
	{
	if ( ticks >= t0.Ticks() && ticks < t1.Ticks() )
		return True;
	else
		return False;
	}



